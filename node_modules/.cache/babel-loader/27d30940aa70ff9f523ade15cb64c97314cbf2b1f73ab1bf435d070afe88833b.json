{"ast":null,"code":"import _toConsumableArray from\"/home/lby005/Desktop/prodj/delt/grapher/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _defineProperty from\"/home/lby005/Desktop/prodj/delt/grapher/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _objectSpread from\"/home/lby005/Desktop/prodj/delt/grapher/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _slicedToArray from\"/home/lby005/Desktop/prodj/delt/grapher/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{useState}from\"react\";import\"../../styles/Graph/Graph.css\";import Canvas from\"../Canvas/Canvas\";import def_graph from'./default.json';import InfoBoard from\"../InfoBoard/InfoBoard\";import Toolbar from\"../ToolBar/Toolbar\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";;/**\n * Generates a random id on the format \"prefix-xxxx\"\n * @param prefix indicates what type of component this id is for\n * @param length the lenght of the random symbols following the prefix\n * @returns \n */var generateID=function generateID(prefix,length){var values=\"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\";var id=prefix+'-';for(var i=0;i<length;i++){var idx=Math.round(Math.random()*(values.length-1));id+=values[idx];}return id;};var Graph=function Graph(props){var _useState=useState(def_graph),_useState2=_slicedToArray(_useState,2),graph=_useState2[0],updateGraph=_useState2[1];var _useState3=useState(\"\"),_useState4=_slicedToArray(_useState3,2),active=_useState4[0],setActive=_useState4[1];var _useState5=useState(\"\"),_useState6=_slicedToArray(_useState5,2),hovered=_useState6[0],setHoverd=_useState6[1];var _useState7=useState(\"select\"),_useState8=_slicedToArray(_useState7,2),toolState=_useState8[0],setToolstate=_useState8[1];/**\n     * Create a new vertex at the given position.\n     * @param position \n     */var newVertex=function newVertex(position){//Generate the new vertex with a unique id\nvar id=generateID('vertex',5);var vertex={edges:[],position:position,symbol:''};updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{vertices:_objectSpread(_objectSpread({},prev.vertices),{},_defineProperty({},id,vertex))});});setActive(function(prev){return id;});};/**\n     * Create a new edge between the two given vertices. \n     * @param vertexA \n     * @param vertexB \n     * @returns\n     */var newEdge=function newEdge(vertexA,vertexB){//make sure that both vertices exists\nif(!(vertexA in graph.vertices&&vertexB in graph.vertices))return;//make sure that the edge is between two different vertices (could be removed in the future)\nif(vertexA==vertexB)return;var double=false;//make sure that this is a unique edge. Only one edge can exist between a given set of vertices AB if the graph is undirected. \nif(Object.entries(graph.edges).map(function(edge){if(edge[1].vertices.b==vertexA&&edge[1].vertices.a==vertexB){if(graph.directed)double=true;else return true;}return edge[1].vertices.a==vertexA&&edge[1].vertices.b==vertexB;}).some(function(val){return val;}))return;//Generate the new edge with a unique id\nvar id=generateID('edge',5);var edge={vertices:{a:vertexA,b:vertexB},weight:0,double:double};//update the involved vertices to be maped to this new edge\nvar updateVerticies=_objectSpread({},graph.vertices);updateVerticies[vertexA]=_objectSpread(_objectSpread({},updateVerticies[vertexA]),{},{edges:[].concat(_toConsumableArray(updateVerticies[vertexA].edges),[id])});updateVerticies[vertexB]=_objectSpread(_objectSpread({},updateVerticies[vertexB]),{},{edges:[].concat(_toConsumableArray(updateVerticies[vertexB].edges),[id])});updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{vertices:updateVerticies,edges:_objectSpread(_objectSpread({},prev.edges),{},_defineProperty({},id,edge))});});setActive(function(prev){return id;});};/**\n     * Remove the given vertex, and all edges connected to it\n     * @param id the id of the vertex\n     * @returns \n     */var removeVertex=function removeVertex(id){//make sure that the id exists in the graph\nif(!(id in graph.vertices))return;var updateVerticies=_objectSpread({},graph.vertices);var updateEdges=_objectSpread({},graph.edges);//remove all connected edges and update their other connected node to no longer refrence this edge.\nupdateVerticies[id].edges.forEach(function(e){var va=updateEdges[e].vertices.a;updateVerticies[va]=_objectSpread(_objectSpread({},updateVerticies[va]),{},{edges:updateVerticies[va].edges.filter(function(edge){return edge!==e;})});var vb=updateEdges[e].vertices.b;updateVerticies[vb]=_objectSpread(_objectSpread({},updateVerticies[vb]),{},{edges:updateVerticies[vb].edges.filter(function(edge){return edge!==e;})});delete updateEdges[e];});delete updateVerticies[id];updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{edges:updateEdges,vertices:updateVerticies});});setActive(function(prev){return\"\";});};/**\n     * Remove the given edge\n     * @param id the id of the edge to remove\n     * @returns \n     */var removeEdge=function removeEdge(id){//make sure that the id exists in the graph\nif(!(id in graph.edges))return;var updateVerticies=_objectSpread({},graph.vertices);var updateEdges=_objectSpread({},graph.edges);//remove the edge and update the connected vertices to no longer refrence this edge\nvar va=updateEdges[id].vertices.a;updateVerticies[va]=_objectSpread(_objectSpread({},updateVerticies[va]),{},{edges:updateVerticies[va].edges.filter(function(edge){return edge!==id;})});var vb=updateEdges[id].vertices.b;updateVerticies[vb]=_objectSpread(_objectSpread({},updateVerticies[vb]),{},{edges:updateVerticies[vb].edges.filter(function(edge){return edge!==id;})});delete updateEdges[id];updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{edges:updateEdges,vertices:updateVerticies});});setActive(function(prev){return\"\";});};/**\n     * move a vertex to a new position\n     * @param id the id of the vertex to move\n     * @param newPosition the new position for the vertex\n     */var moveVertex=function moveVertex(id,newPosition){var updateVerticies=_objectSpread({},graph.vertices);updateVerticies[id]=_objectSpread(_objectSpread({},updateVerticies[id]),{},{position:newPosition});updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{vertices:updateVerticies});});};/**\n     * Set a new weight value for an edge in a weighted graph\n     * @param id the id of the edge to update\n     * @param value the new weight\n     */var editWeight=function editWeight(id,value){var updateEdges=_objectSpread({},graph.edges);updateEdges[id]=_objectSpread(_objectSpread({},updateEdges[id]),{},{weight:value});updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{edges:updateEdges});});};/**\n     * Set a new label for a vertex\n     * @param id the id of the vertex to update\n     * @param value the new label\n     */var editLabel=function editLabel(id,value){var updateVerticies=_objectSpread({},graph.vertices);updateVerticies[id]=_objectSpread(_objectSpread({},updateVerticies[id]),{},{symbol:value});updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{vertices:updateVerticies});});};/**\n     * fetch a color based on if the components id is marked as active, hovered or none of them\n     * @param id the id of the graph component\n     * @returns a string representing a color name or color code.\n     */var getColor=function getColor(id){return active==id?\"salmon\":hovered==id?\"skyblue\":\"#F3E99F\";};/**\n     * Checks if an id belongs to a vertex. Should be used with ids generated by the generateID method.\n     * @param id the id to check\n     * @returns true if the prefix of the id is 'vertex', false if not\n     */var isVertex=function isVertex(id){return id.split('-')[0]=='vertex';};/**\n     * Based on the toolstate, this method determins what to do when this method is called from a component.\n     * @param id the id of the component calling the method\n     * @param position the position of the cursor at the time of calling this method\n     */var update=function update(){var id=arguments.length>0&&arguments[0]!==undefined?arguments[0]:\"\";var position=arguments.length>1?arguments[1]:undefined;var vertex=isVertex(id);switch(toolState){case'select':if(vertex)moveVertex(id,position);if(id!=\"\")setActive(function(prev){return id;});break;case'delete':vertex?removeVertex(id):removeEdge(id);break;case'add':if(vertex&&isVertex(active))newEdge(active,id);else if(id==\"\")newVertex(position);else setActive(function(prev){return id;});break;default:break;}};return/*#__PURE__*/_jsxs(\"div\",{className:\"graph-container\",children:[/*#__PURE__*/_jsx(\"div\",{className:\"graph-header\",children:\"Grapher\"}),/*#__PURE__*/_jsxs(\"div\",{className:\"graph-body\",children:[/*#__PURE__*/_jsx(InfoBoard,{graph:graph,active:active,setActive:setActive,setHovered:setHoverd,editWeight:editWeight,editLabel:editLabel}),/*#__PURE__*/_jsx(Canvas,{graph:graph,updateGraph:update,active:active,hovered:hovered,setHoverd:setHoverd,getColor:getColor}),/*#__PURE__*/_jsx(\"div\",{children:\" **algoritmeverkt\\xF8y**\"})]}),/*#__PURE__*/_jsxs(\"div\",{className:\"graph-footer\",children:[/*#__PURE__*/_jsxs(\"div\",{onChange:function onChange(){return setActive(\"\");},children:[/*#__PURE__*/_jsxs(\"label\",{children:[/*#__PURE__*/_jsx(\"input\",{type:\"checkbox\",checked:graph.directed,onChange:function onChange(){return updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{directed:!prev.directed});});}}),\"Directed\"]}),/*#__PURE__*/_jsxs(\"label\",{children:[/*#__PURE__*/_jsx(\"input\",{type:\"checkbox\",checked:graph.weighted,onChange:function onChange(){return updateGraph(function(prev){return _objectSpread(_objectSpread({},prev),{},{weighted:!prev.weighted});});}}),\"Weighted\"]})]}),/*#__PURE__*/_jsx(Toolbar,{toolState:toolState,setToolState:function setToolState(newState){setToolstate(function(prev){return newState;});setActive('');}})]})]});};export default Graph;","map":{"version":3,"names":["useState","Canvas","def_graph","InfoBoard","Toolbar","jsx","_jsx","jsxs","_jsxs","generateID","prefix","length","values","id","i","idx","Math","round","random","Graph","props","_useState","_useState2","_slicedToArray","graph","updateGraph","_useState3","_useState4","active","setActive","_useState5","_useState6","hovered","setHoverd","_useState7","_useState8","toolState","setToolstate","newVertex","position","vertex","edges","symbol","prev","_objectSpread","vertices","_defineProperty","newEdge","vertexA","vertexB","double","Object","entries","map","edge","b","a","directed","some","val","weight","updateVerticies","concat","_toConsumableArray","removeVertex","updateEdges","forEach","e","va","filter","vb","removeEdge","moveVertex","newPosition","editWeight","value","editLabel","getColor","isVertex","split","update","arguments","undefined","className","children","setHovered","onChange","type","checked","weighted","setToolState","newState"],"sources":["/home/lby005/Desktop/prodj/delt/grapher/src/components/Graph/Graph.tsx"],"sourcesContent":["import { useState } from \"react\";\nimport \"../../styles/Graph/Graph.css\";\nimport Canvas from \"../Canvas/Canvas\";\n\nimport def_graph from './default.json';\nimport InfoBoard from \"../InfoBoard/InfoBoard\";\nimport Toolbar from \"../ToolBar/Toolbar\";\n\ninterface IVertex {\n    edges : string[]\n    position : {x: number, y: number},\n    symbol: string\n}\n\ninterface IEdge {\n    vertices : {a: string, b: string},\n    weight : number,\n    double : boolean,\n}\n\nexport interface IGraph {\n    weighted : boolean,\n    directed : boolean,\n    vertices : { [id: string] : IVertex },\n    edges : { [id: string] : IEdge }\n}\n\ninterface Props {};\n\n/**\n * Generates a random id on the format \"prefix-xxxx\"\n * @param prefix indicates what type of component this id is for\n * @param length the lenght of the random symbols following the prefix\n * @returns \n */\nconst generateID = (prefix: string, length: number) => {\n    const values = \"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890\";\n    var id = prefix + '-';\n    for (let i = 0; i < length; i++) {\n        let idx = Math.round(Math.random() * (values.length-1));\n        id += values[idx];\n    }\n    return id;\n}\n\n\nconst Graph = (props: Props) => {\n\n    const [graph, updateGraph] = useState<IGraph>(def_graph);\n    const [active, setActive] = useState<string>(\"\");\n    const [hovered, setHoverd] = useState<string>(\"\");\n    const [toolState, setToolstate] = useState<string>(\"select\");\n\n\n    /**\n     * Create a new vertex at the given position.\n     * @param position \n     */\n    const newVertex = (position:{x:number,y:number}) => {\n        //Generate the new vertex with a unique id\n        const id = generateID('vertex',5);\n        const vertex : IVertex = {\n            edges : [],\n            position : position,\n            symbol: ''\n        }\n\n        updateGraph((prev: IGraph) => ({...prev, vertices : {...prev.vertices, [id] : vertex}}))\n        setActive((prev) => id);\n    }\n\n    \n    /**\n     * Create a new edge between the two given vertices. \n     * @param vertexA \n     * @param vertexB \n     * @returns\n     */\n    const newEdge = (vertexA : string, vertexB : string) => {\n\n        //make sure that both vertices exists\n        if (!(vertexA in graph.vertices && vertexB in graph.vertices)) return\n     \n        //make sure that the edge is between two different vertices (could be removed in the future)\n        if ( vertexA == vertexB ) return;\n\n        let double = false;\n\n        //make sure that this is a unique edge. Only one edge can exist between a given set of vertices AB if the graph is undirected. \n        if ( Object.entries(graph.edges).map(edge => {\n            if ( edge[1].vertices.b == vertexA && edge[1].vertices.a == vertexB ) {\n                if (graph.directed) double = true;\n                else return true;\n            }\n            return (edge[1].vertices.a == vertexA && edge[1].vertices.b == vertexB);\n        }).some(val => val)) return;\n\n        //Generate the new edge with a unique id\n        const id = generateID('edge',5);\n        const edge : IEdge = {\n            vertices : {a: vertexA, b: vertexB},\n            weight : 0,\n            double : double\n        }\n\n        //update the involved vertices to be maped to this new edge\n        const updateVerticies = {...graph.vertices};     \n        updateVerticies[vertexA] = {...updateVerticies[vertexA], edges :  [...updateVerticies[vertexA].edges, id]}\n        updateVerticies[vertexB] = {...updateVerticies[vertexB], edges :  [...updateVerticies[vertexB].edges, id]}\n\n        updateGraph((prev: IGraph) => ({...prev, vertices: updateVerticies, edges : {...prev.edges, [id] : edge}}))\n        setActive((prev) => id);\n    }\n\n    /**\n     * Remove the given vertex, and all edges connected to it\n     * @param id the id of the vertex\n     * @returns \n     */\n    const removeVertex = (id : string) => {\n        //make sure that the id exists in the graph\n        if (!(id in graph.vertices)) return;\n\n        const updateVerticies = {...graph.vertices};\n        const updateEdges = {...graph.edges};\n\n        //remove all connected edges and update their other connected node to no longer refrence this edge.\n        updateVerticies[id].edges.forEach(e => {\n\n            let va = updateEdges[e].vertices.a;\n            updateVerticies[va] = {...updateVerticies[va], edges :  updateVerticies[va].edges.filter(edge => edge !== e)};\n            \n            let vb = updateEdges[e].vertices.b;\n            updateVerticies[vb] = {...updateVerticies[vb], edges :  updateVerticies[vb].edges.filter(edge => edge !== e)};\n\n\n            delete updateEdges[e];\n        });\n    \n        delete updateVerticies[id];\n\n        updateGraph((prev: IGraph) => ({...prev, edges : updateEdges, vertices : updateVerticies}))\n        setActive((prev) => \"\");\n    }\n\n    /**\n     * Remove the given edge\n     * @param id the id of the edge to remove\n     * @returns \n     */\n    const removeEdge = (id : string) => {\n        //make sure that the id exists in the graph\n        if (!(id in graph.edges)) return;\n\n        const updateVerticies = {...graph.vertices};\n        const updateEdges = {...graph.edges};\n\n        //remove the edge and update the connected vertices to no longer refrence this edge\n        let va = updateEdges[id].vertices.a\n        updateVerticies[va] = {...updateVerticies[va], edges :updateVerticies[va].edges.filter(edge => edge !== id)}\n        let vb = updateEdges[id].vertices.b\n        updateVerticies[vb] = {...updateVerticies[vb], edges :updateVerticies[vb].edges.filter(edge => edge !== id)}\n        \n        delete updateEdges[id];\n\n        updateGraph((prev: IGraph) => ({...prev, edges : updateEdges, vertices : updateVerticies}))\n        setActive((prev) => \"\");\n    }\n\n \n    /**\n     * move a vertex to a new position\n     * @param id the id of the vertex to move\n     * @param newPosition the new position for the vertex\n     */\n    const moveVertex = (id: string, newPosition: {x: number, y: number}) => {\n        const updateVerticies = {...graph.vertices};     \n        updateVerticies[id] = {...updateVerticies[id], position :  newPosition}\n\n        updateGraph((prev: IGraph) => ({...prev, vertices : updateVerticies}))\n    }\n\n    /**\n     * Set a new weight value for an edge in a weighted graph\n     * @param id the id of the edge to update\n     * @param value the new weight\n     */\n    const editWeight = (id: string, value: number) => {    \n        const updateEdges = {...graph.edges};\n        updateEdges[id] = {...updateEdges[id], weight : value};\n\n        updateGraph((prev: IGraph) => ({...prev, edges : updateEdges}))\n    }\n\n    /**\n     * Set a new label for a vertex\n     * @param id the id of the vertex to update\n     * @param value the new label\n     */\n    const editLabel = (id: string, value: string) => {    \n        const updateVerticies = {...graph.vertices};     \n        updateVerticies[id] = {...updateVerticies[id], symbol :  value}\n\n        updateGraph((prev: IGraph) => ({...prev, vertices : updateVerticies}))\n    }\n\n    /**\n     * fetch a color based on if the components id is marked as active, hovered or none of them\n     * @param id the id of the graph component\n     * @returns a string representing a color name or color code.\n     */\n    const getColor = (id:string) => {\n        return active == id ? \"salmon\" : hovered == id ? \"skyblue\" : \"#F3E99F\"\n    };\n\n    /**\n     * Checks if an id belongs to a vertex. Should be used with ids generated by the generateID method.\n     * @param id the id to check\n     * @returns true if the prefix of the id is 'vertex', false if not\n     */\n    const isVertex = (id: string) => {\n        return id.split('-')[0] == 'vertex';\n    }\n\n    /**\n     * Based on the toolstate, this method determins what to do when this method is called from a component.\n     * @param id the id of the component calling the method\n     * @param position the position of the cursor at the time of calling this method\n     */\n    const update = (id : string = \"\", position : {x:number, y: number}) => {\n        let vertex = isVertex(id); \n        \n        switch (toolState) {\n            case 'select':\n                if ( vertex ) moveVertex(id,position);\n                if ( id != \"\") setActive((prev) => id);\n                break;\n            case 'delete':\n                vertex ? removeVertex(id) : removeEdge(id);\n                break;\n            case 'add':\n                if ( vertex && isVertex(active) ) newEdge(active,id);\n                else if ( id == \"\" ) newVertex(position);\n                else setActive((prev) => id);\n                break;\n            default:\n                break;\n        }\n    }\n\n    return (\n        <div className=\"graph-container\">\n            <div className=\"graph-header\">\n                Grapher\n            </div>\n            <div className=\"graph-body\">\n                <InfoBoard \n                    graph={graph} \n                    active={active}\n                    setActive={setActive}\n                    setHovered={setHoverd}\n                    editWeight={editWeight}\n                    editLabel={editLabel}></InfoBoard>\n\n                <Canvas \n                    graph={graph}\n                    updateGraph={update}\n                    active={active}\n                    hovered={hovered}\n                    setHoverd={setHoverd}\n                    getColor={getColor}\n                ></Canvas>\n\n                <div> **algoritmeverkt√∏y**</div>\n\n            </div>\n            <div className=\"graph-footer\">\n                <div onChange={() => setActive(\"\")}>\n                    <label>\n                        <input type=\"checkbox\" checked={graph.directed} onChange={() => updateGraph((prev: IGraph) => ({...prev, directed : !prev.directed}))}/>\n                        Directed\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={graph.weighted} onChange={() => updateGraph((prev: IGraph) => ({...prev, weighted : !prev.weighted}))}/>\n                        Weighted\n                    </label>\n                </div>\n                \n                <Toolbar toolState={toolState} setToolState={(newState:string) => {setToolstate((prev) => newState); setActive('')}}></Toolbar>\n            </div>\n\n\n\n\n\n\n\n        </div>\n    );\n};\n\nexport default Graph;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}